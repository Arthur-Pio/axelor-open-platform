= Configurations
:toc:
:toc-title:

:url-mysql: https://www.mysql.com/
:url-oracle: http://www.oracle.com/technetwork/indexes/downloads/index.html#database

:url-caffeine: https://github.com/ben-manes/caffeine
:url-hazelcast: https://hazelcast.com/
:url-redis: https://redis.io/
:url-infinispan: https://infinispan.org/
:url-ehcache: https://www.ehcache.org/

In this chapter we will see various configuration options available to the {page-component-title}
applications.

== Introduction

The application configuration is provided through various configuration files.
These are:

- `axelor-config.properties` - the application configuration
- `persistence.xml` - hibernate/jpa configuration

The most important of them is `axelor-config.properties`.

== Application Configuration

AOP reads configuration values from multiple sources (in this ascendant order):

* Internal configuration file under `src/main/resources`.
* External configuration file using `AXELOR_CONFIG` environment variable
or `axelor.config` system property.
* Environment variables prefixed with `AXELOR_CONFIG_`
* System properties prefixed with `axelor.config.`

Each of these sources overrides values of the previous. The final configuration is the
aggregation of the properties defined by all these sources.
For example, a property configured using an environment property  overrides the value
provided using the axelor-config.properties file.

=== Internal configuration

The main `axelor-config.properties` provides various configuration values for the
application. It's located under `src/main/resources` directory of the
application project.

Note that this internal configuration file is optional.

YAML format is also supported. `axelor-config.properties` can be in YAML format
(`yml` or `yaml` ext). It should only have a one internal configuration file
(in properties or YAML format).

=== External configuration

The external configuration file is similar to the internal configuration file.
It can a properties file or a YAML file format.

To use external configuration file, either add `AXELOR_CONFIG` environment variable
or `axelor.config` system property. Note that system properties gets preferences
over the environment variable

[source,sh]
----
$ export JAVA_OPTS="-Daxelor.config=/path/to/dev.properties"
----

=== Environment variables

Environment variables should be prefixed by `AXELOR_CONFIG_`.
It uses the `AXELOR_CONFIG_<key>=value` format, where `<key>` is underscored
uppercase equivalent of the configuration key. For example
`db.default.user` becomes `AXELOR_CONFIG_DB_DEFAULT_USER`.

[source,sh]
----
$ export AXELOR_CONFIG_DB_DEFAULT_PASSWORD=secret"
----

=== System properties

System properties can be handed to the application through the `-D` flag during startup
System properties should be prefixed by `axelor.config.`.
It uses the `axelor.config<key>=value` format, where `<key>` is a setting name.

[source,sh]
----
$ export JAVA_OPTS="-Daxelor.config.db.default.password=secret"
----

=== Encoded properties

Configuration values can be encrypted. Value should be wrapped in `ENC()` to indicate
that the value is encrypted : `db.default.password = ENC(<some_thing>)`

To use encrypted secrets, `config.encryptor.password` properties
should be added : this is the secret key used to encrypt/decrypt data.

Others optional properties can be added to use custom encryption :

* `config.encryptor.algorithm` :Algorithm to be used by the encryptor
* `config.encryptor.key-obtention-iterations` : Number of hashing iterations to obtain the signing key
* `config.encryptor.provider-name` : Name of the security provider to be asked for the encryption algorithm
* `config.encryptor.provider-class-name` : Security provider to be used for obtaining the encryption algorithm
* `config.encryptor.salt-generator-classname` : Salt generator to be used by the encryptor
* `config.encryptor.iv-generator-classname` : IV generator to be used by the encryptor
* `config.encryptor.string-output-type` : Sets the form in which String output will be encoded

The default algorithm is `PBEWITHHMACSHA512ANDAES_256`. Most of the time,
default encryption configuration will be enough.

For convenience, 2 Gradle task has been added to deal with encryption :

* `encryptText` : Encrypt a single given String
* `encryptFile` : Search and encrypt for values wrapped with `ENC()` in configuration file

==== Task 'encryptText'

To encrypt a single given String, run:

[source,bash]
----
$ ./gradlew :encryptText --text="A secret to encode" --password="MySecureKey"

-------Configs-------
config.encryptor.password = MySecureKey

WARNING : Do not add property `config.encryptor.password` with the password in your configuration file.
Use a reference to an external file : `file:<path_to_file>` as password value.

-------OUTPUT-------
EFevga4IJ68kgt+YS8nuRXt/7TmvL94aVGCU2l5WeBLDn4ie8tZM7UjypiBZA4rCTv4VogKAB1wRAJZpa3q12w==
----

This will generate for you, the necessary properties and the
encrypted value to used inside `ENC()`.

==== Task 'encryptFile'

To search and encrypt all properties wrapped with `ENC()` in configuration file, run:

[source,bash]
----
$ ./gradlew :encryptFile --password="MySecureKey"

-------Configs-------
config.encryptor.password = MySecureKey

WARNING : Do not add property `config.encryptor.password` with the password in your configuration file.
Use a reference to an external file : `file:<path_to_file>` as password value.

-------OUTPUT-------
Found and encrypt 1 setting(s) : db.default.password
----

This will encrypt all settings in the configuration file for you.
By default, it looks for a configuration file in current project. If needed,
that file can be overridden with parameter `--file="<path_to_file>"`.
Encryption settings (`algorithm`, `key-obtention-iterations`, ...) are
determinate from that configuration file. This can be overridden with
CLI arguments : `--algorithm="PBEWithMD5AndTripleDES"`, ...

== Database Settings

We can configure database connection settings with following properties:

[source,properties]
----
# Database settings
# ~~~~~
# See hibernate documentation for connection parameters
db.default.ddl = update <1>
db.default.url = jdbc:postgresql://localhost:5432/my-database <2>
db.default.user = username <3>
db.default.password = secret <4>
----
<1> hbm2ddl option, (update, create, create-drop or validate)
<2> the jdbc url to connect to
<3> user name to be used to connect to the database server
<4> user password to authenticate the user

If you want to use {url-mysql}[MySQL] use following settings:

[source,properties]
----
# Database settings
# ~~~~~
# See hibernate documentation for connection parameters
db.default.ddl = update
db.default.url = jdbc:mysql://localhost:3306/my_database
db.default.user = username
db.default.password = secret
----

== Others Settings

[cols="1,9"]
|===
| Key Name | Description
| `application.name` | application name, e.g. axelor-erp
| `application.name` | application name
| `application.description` | application description
| `application.version` | application version
| `application.author` | application author
| `application.copyright` | application copyright
| `application.logo` | header logo. Should be 40px in height with transparent background (default is img/axelor-logo.png)
| `application.home` | home website. Link to be used with header logo.
| `application.help` | link to the online help
| `application.mode` | application deployment mode. Can be `prod` or `dev` (default is dev)
| `application.theme` | CSS theme. If not defined, default theme is used.
| `application.locale` | default locale (if not set, system default is used)
| `session.timeout` | session timeout in minutes (default is 60)
| `file.upload.dir` | storage path for upload files for attachments (default is \{user.home}/.axelor/attachments)
| `file.upload.size` | maximum upload size in MB (default is 5 MB)
| `file.upload.whitelist.pattern` | whitelist file name pattern, only matching files will be allowed
| `file.upload.blacklist.pattern` | blacklist file name pattern, maching files will be rejected
| `file.upload.whitelist.types` | whitelist file mime types, detects content type
| `file.upload.blacklist.types` | blacklist file mime types, detects content type
| `reports.design.dir` | external directory for birt report designs (default is \{user.home}/.axelor/reports)
| `reports.output.dir` | external directory for generated pdf reports (default is \{user.home}/.axelor/reports-gen)
| `data.export.encoding` | data export (csv) encoding (default is ISO_8859_1)
| `data.export.dir` | storage path for export action (default is \{user.home}/.axelor/data-export)
| `data.import.demo-data` | whether to import demo data for the application (default is true)
| `template.search.dir` | storage path for templates (default is \{user.home}/.axelor/templates)
| `view.single.tab` | whether to use single tab layout (default is false)
| `view.menubar.location` | set menu style. Can be `left`, `top` or `both` (default is left)
| `view.toolbar.titles` | whether to show button titles in toolbar (default is false)
| `view.confirm.yes-no` | whether show confirm dialog with yes/no buttons (default is Cancel/OK)
| `view.grid.selection` | if set to `checkbox`, grid widgets will have checkbox selection enabled
|===

All specified path can use specials variables :

* `{user.home}` : reference to the home directory, `System.getProperty("user.home")`
* `{java.io.tmpdir}` : reference to the tmp directory, `System.getProperty("java.io.tmpdir")`

The differences between `prod` and `dev` mode are :

* use minify js/css file.
* use browser cache.
* don't display technical popup.

== Example configuration

Here is a complete configuration file with default values

[source,properties]
----
include::{examplesdir}/axelor-config.properties[]
----

== JPA/Hibernate Configuration

The `persistence.xml` located under `src/main/resources/META-INF` provides
JPA/Hibernate configuration.

A minimal persistence xml file is required to confirm JPA requirements:

.persistence.xml
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<persistence version="2.1"
  xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
  <persistence-unit name="persistenceUnit" transaction-type="RESOURCE_LOCAL">
    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
    <shared-cache-mode>ENABLE_SELECTIVE</shared-cache-mode>
  </persistence-unit>
</persistence>
----

== Logging Configuration

The logging can be configured from `axelor-config.properties` using following properties:

[source,properties]
----
# Logging
# ~~~~~
# Custom logback configuration can be provided with `logging.config` property pointing
# to a custom `logback.xml`. In this case, all the logging configuration provided here
# will be ignored.
#
# Following settings can be used to configure logging system automatically.
#
#logging.path = {user.home}/.axelor/logs
#logging.pattern.file = %d{yyyy-MM-dd HH:mm:ss.SSS} %5p ${PID:- } --- [%t] %-40.40logger{39} : %m%n
#logging.pattern.console = %clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n

# Global logging
logging.level.root = ERROR

# Axelor logging

# Log everything.
logging.level.com.axelor = DEBUG

# Hibernate logging

# Log everything. Good for troubleshooting
#logging.level.org.hibernate = INFO

# Log all SQL DML statements as they are executed
#logging.level.org.hibernate.SQL = DEBUG
#logging.level.org.hibernate.engine.jdbc = DEBUG

# Log all SQL DDL statements as they are executed
#logging.level.org.hibernate.tool.hbm2ddl = INFO

# Log all JDBC parameters
#logging.level.org.hibernate.type = ALL

# Log transactions
#logging.level.org.hibernate.transaction = DEBUG

# Log L2-Cache
#logging.level.org.hibernate.cache = DEBUG

# Log JDBC resource acquisition
#logging.level.org.hibernate.jdbc = TRACE
#logging.level.org.hibernate.service.jdbc = TRACE

# Log connection pooling
#logging.level.com.zaxxer.hikari = INFO
----

The `logging.path` can be used to save logs to file.
The `logging.pattern.file` can be used to change log message format for file logging
The `logging.pattern.console` can be used to change log message format for console logging

We can set logging for any package using `logging.level.<package.name>` keys.

== Cache Configuration

Property `javax.persistence.sharedCache.mode` can be used to enable or disable second level caching.

Following keys can be used :

* `ALL` : Entities are always cached even if marked as non-cacheable.
* `ENABLE_SELECTIVE` : Entities are not cached unless explicitly marked as cacheable
(with the `@Cacheable` annotation). This is the recommended configuration.
* `DISABLE_SELECTIVE` : Entities are cached unless explicitly marked as non-cacheable.
* `NONE` (or anything else) : Completely disable second-level cache.

`jcache` is used as second-level cache provider (default value for `hibernate.cache.region.factory_class`).

By default `Caffeine` implementation is used with pre-configured settings. If you need more control on caching,
add and edit `application.conf`. See `Caffeine` configs and settings.

There is also populars caching libraries such as {url-ehcache}[Ehcache],
{url-hazelcast}[Hazelcast], {url-redis}[Redis] or {url-infinispan}[Infinispan] that can be used instead of
`Caffeine` by specifying properties `hibernate.cache.region.factory_class` and `hibernate.javax.cache.provider` :

*Infinispan :*
[source,gradle]
----
implementation "org.infinispan:infinispan-hibernate-cache-v53:${infinispan_version}"
implementation "org.infinispan:infinispan-core:${infinispan_version}"
implementation "org.infinispan:infinispan-jcache:${infinispan_version}"
----
[source,properties]
----
hibernate.cache.region.factory_class = infinispan
hibernate.cache.infinispan.cfg = org/infinispan/hibernate/cache/commons/builder/infinispan-configs-local.xml
----

*Redis :*
[source,gradle]
----
implementation "org.redisson:redisson-hibernate-53:${redisson_version}"
----
[source,properties]
----
hibernate.cache.region.factory_class = org.redisson.hibernate.RedissonRegionFactory
# Make sure to add Redisson YAML config in classpath
----

*Hazelcast :*
[source,gradle]
----
implementation "com.hazelcast:hazelcast:${hazelcast_version}"
----
[source,properties]
----
hibernate.javax.cache.provider = com.hazelcast.cache.impl.HazelcastServerCachingProvider
# You may need to add `-Dhazelcast.ignoreXxeProtectionFailures=true` system property
----

*Ehcache :*
[source,gradle]
----
implementation "org.ehcache:ehcache:${ehcache_version}"
----
[source,properties]
----
hibernate.javax.cache.provider = org.ehcache.jsr107.EhcacheCachingProvider
----

Makes sure to add required dependencies if you want to use another caching library. Refer to providers docs for
extensive configuration : all properties prefix by `hibernate.` will be used.

== Global Context Configuration

Besides the static configuration values, we can also provide configuration for
dynamic global context with `context.` prefix. It's used by actions and script
handlers when evaluating expressions and domain filters. The values can be
referenced from expressions with special variable `\\__config__`.

[source,properties]
----
# Custom context
# ~~~~~

# instance
context.hello = com.axelor.script.TestContext

# instance method
context.world = com.axelor.script.TestContext:hello

# static method
context.some = com.axelor.script.TestContext:staticMethod

# static field
context.thing = com.axelor.script.TestContext:STATIC_FIELD

# static values
context.flag = true
context.string = some static text value
context.number = 100
----

Now, we can use them in expressions like this:

[source,xml]
----
<field ... value="#{__config__.hello.message}" /> <1>
<field ... value="#{__config__.world}" /> <2>
<field ... value="#{__config__.some}" /> <3>
<field ... value="#{__config__.thing}" /> <4>
<field ... value="#{__config__.flag}" /> <5>
----
<1> calls getter on the instance
<2> calls an instance method
<3> calls a static method
<4> public static final field value
<5> any constant value

== Custom Logo

A special context setting `context.appLogo` can be used to dynamically change
header logo per user. For example:

[source,properties]
----
context.appLogo = com.axelor.custom.LogoService:getLogo
----

The `getLogo()` method then can return link to user specific application logo.

== Custom Style

A special context setting `context.appStyle` can be used to provide custom style
for web ui. For example:

[source,properties]
----
context.appStyle = com.axelor.custom.StyleService:getStyle
----

and the code:

[source,java]
----
public class StyleService {

  public String getStyle() {
    // we can even read the style from database
    return "header .navbar .nav .fa-bars { color: #86bc25; }"; <1>
  }
}
----
<1> change the color of sidebar toggle icon

The `getStyle()` method should return custom style as String value.

The custom style is applied in following order:

. default style
. user theme if available
. custom style if provided

So the custom style will aways override default and theme styles.
