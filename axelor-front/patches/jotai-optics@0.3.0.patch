diff --git a/dist/src/focusAtom.d.ts b/dist/src/focusAtom.d.ts
index f99cdf5ec51a03d67481b756d72cd6f9b46486ab..a16e1453363997d2772914296c2a6dbb9527a0b9 100644
--- a/dist/src/focusAtom.d.ts
+++ b/dist/src/focusAtom.d.ts
@@ -1,16 +1,16 @@
 import type { SetStateAction, WritableAtom } from 'jotai/vanilla';
 import * as O from 'optics-ts';
 type NonFunction<T> = [T] extends [(...args: any[]) => any] ? never : T;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<Promise<A>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Prism<S, any, A>): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Traversal<S, any, A>): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<Promise<A>, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S>) => O.Traversal<S, any, A>): WritableAtom<A[], [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Prism<S, any, A>): WritableAtom<A | undefined, [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Traversal<S, any, A>): WritableAtom<A[], [SetStateAction<A>], R>;
-export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor<S | undefined>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Prism<S, any, A>): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Traversal<S, any, A>): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<Promise<A>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Prism<S, any, A>): WritableAtom<Promise<A | undefined>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Traversal<S, any, A>): WritableAtom<Promise<A[]>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<Promise<S | undefined>, [Promise<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<Promise<A>, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Prism<S, any, A>): WritableAtom<A | undefined, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Traversal<S, any, A>): WritableAtom<A[], [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Prism<S, any, A>): WritableAtom<A | undefined, [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Traversal<S, any, A>): WritableAtom<A[], [SetStateAction<A>], R>;
+export declare function focusAtom<S, A, R>(baseAtom: WritableAtom<S | undefined, [NonFunction<S>], R>, callback: (optic: O.OpticFor_<S | undefined>) => O.Lens<S, any, A> | O.Equivalence<S, any, A> | O.Iso<S, any, A>): WritableAtom<A, [SetStateAction<A>], R>;
 export {};